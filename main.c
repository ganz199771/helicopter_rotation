/******************************************************************************
* File Name:   main.c
*
* Description: This is the source code for the XMC MCU: Empty Application
*              Template for ModusToolbox.
*
* Related Document: See README.md
*
******************************************************************************
*
* Copyright (c) 2015-2021, Infineon Technologies AG
* All rights reserved.                        
*                                             
* Boost Software License - Version 1.0 - August 17th, 2003
* 
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
* 
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*                                                                              
*****************************************************************************/

#include "cybsp.h"
#include "cy_utils.h"
#include "xmc_gpio.h"
#include "xmc_uart.h"
#include "cycfg_peripherals.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "retarget_io.h"
#include <cmd.h>

#define TICKS_PER_SECOND        1000
#define TICKS_WAIT              1000

#define R1 10 /* 10K电阻 */
#define R_ERROR 0.005f /* 5Ω误差 */
/**
 *  电阻(kohm)                      高电平时间(us)
 *  0.3                             1095
 *  0.8                             1180
 *  1.5                             1223
 *  2.1                             1266
 *  2.4                             1309
 *  3.1                             1352
 *  3.5                             1394
 *  3.9                             1437
 *  4.5                             1480
 *  5.2                             1522
 *  5.7                             1565
 *  6.0                             1608
 *  6.5                             1651
 *  7.2                             1694
 *  7.5                             1736
 *  8.1                             1779
 *  8.4                             1822
 *  8.9                             1864
 *  9.2                             1907
 *  10                              1950
 */

#define PWM_0_KOHM  0.3f
#define PWM_0_US    1095
#define PWM_10_KOHM  0.8f
#define PWM_10_US    1180
#define PWM_15_KOHM  1.5f
#define PWM_15_US    1223
#define PWM_20_KOHM  2.1f
#define PWM_20_US    1266
#define PWM_25_KOHM  2.4f
#define PWM_25_US    1309
#define PWM_30_KOHM  3.1f
#define PWM_30_US    1352
#define PWM_35_KOHM  3.5f
#define PWM_35_US    1394
#define PWM_40_KOHM  3.9f
#define PWM_40_US    1437
#define PWM_45_KOHM  4.5f
#define PWM_45_US    1480
#define PWM_50_KOHM  5.2f
#define PWM_50_US    1522
#define PWM_55_KOHM  5.7f
#define PWM_55_US    1565
#define PWM_60_KOHM  6.0f
#define PWM_60_US    1608
#define PWM_65_KOHM  6.5f
#define PWM_65_US    1651
#define PWM_70_KOHM  7.2f
#define PWM_70_US    1694
#define PWM_75_KOHM  7.5f
#define PWM_75_US    1736
#define PWM_80_KOHM  8.1f
#define PWM_80_US    1779
#define PWM_85_KOHM  8.4f
#define PWM_85_US    1822
#define PWM_90_KOHM  8.9f
#define PWM_90_US    1864
#define PWM_95_KOHM  9.2f
#define PWM_95_US    1907
#define PWM_100_KOHM  10.0f
#define PWM_100_US    1950

#define PWM_TICK_US 10.667f /* 节拍步长 */

static volatile uint32_t ticks = 0;

static float res_ohm = 0; /* 可调电阻的阻值 */
static uint16_t pwm_compare = 0;


void SysTick_Handler(void)
{
    ticks++;
}

enum led_status
{
    on,
    off,
    toogle
};
static enum led_status led_light_status = off;
static void led_ctrl(enum led_status status)
{
    if(status == on)
    {
        XMC_GPIO_SetOutputHigh(led_pin_PORT, led_pin_PIN);
    }
    else if(status == off)
    {
        XMC_GPIO_SetOutputLow(led_pin_PORT, led_pin_PIN);
    }
    else
    {
        if(led_light_status == on)
        {
            XMC_GPIO_SetOutputLow(led_pin_PORT, led_pin_PIN);
            led_light_status = off;
        }
        else
        {
            XMC_GPIO_SetOutputHigh(led_pin_PORT, led_pin_PIN);
            led_light_status = on;
        }
    }
}

/// @brief 更新PWM比较寄存器值
static void update_pwm_compare()
{
    if(res_ohm <= PWM_0_KOHM) /* 线性区间，自己调整 */
    {
        pwm_compare = PWM_0_US;
    }
    else if(res_ohm >= (PWM_10_KOHM - R_ERROR) && res_ohm <= (PWM_10_KOHM + R_ERROR))
    {
        pwm_compare = PWM_10_US;
    }
    else if(res_ohm > PWM_0_KOHM && res_ohm < PWM_10_KOHM) /* 线性区间，自己调整 */
    {
        pwm_compare = (res_ohm - PWM_0_KOHM) / (PWM_10_KOHM - PWM_0_KOHM) * (PWM_10_US - PWM_0_US) + PWM_0_US;
    }
    else if(res_ohm >= (PWM_15_KOHM - R_ERROR) && res_ohm <= (PWM_15_KOHM + R_ERROR))
    {
        pwm_compare = PWM_15_US;
    }
    else if(res_ohm > PWM_10_KOHM && res_ohm < PWM_15_KOHM)
    {
        pwm_compare = (res_ohm - PWM_10_KOHM) / (PWM_15_KOHM - PWM_10_KOHM) * (PWM_15_US - PWM_10_US) + PWM_10_US;
    }
    else if(res_ohm >= (PWM_20_KOHM - R_ERROR) && res_ohm <= (PWM_20_KOHM + R_ERROR))
    {
        pwm_compare = PWM_20_US;
    }
    else if(res_ohm > PWM_15_KOHM && res_ohm < PWM_20_KOHM)
    {
        pwm_compare = (res_ohm - PWM_15_KOHM) / (PWM_20_KOHM - PWM_15_KOHM) * (PWM_20_US - PWM_15_US) + PWM_15_US;
    }
    else if(res_ohm >= (PWM_25_KOHM - R_ERROR) && res_ohm <= (PWM_25_KOHM + R_ERROR))
    {
        pwm_compare = PWM_25_US;
    }
    else if(res_ohm > PWM_20_KOHM && res_ohm < PWM_25_KOHM)
    {
        pwm_compare = (res_ohm - PWM_20_KOHM) / (PWM_25_KOHM - PWM_20_KOHM) * (PWM_25_US - PWM_20_US) + PWM_20_US;
    }
    else if(res_ohm >= (PWM_30_KOHM - R_ERROR) && res_ohm <= (PWM_30_KOHM + R_ERROR))
    {
        pwm_compare = PWM_30_US;
    }
    else if(res_ohm > PWM_25_KOHM && res_ohm < PWM_30_KOHM)
    {
        pwm_compare = (res_ohm - PWM_25_KOHM) / (PWM_30_KOHM - PWM_25_KOHM) * (PWM_30_US - PWM_25_US) + PWM_25_US;
    }
    else if(res_ohm >= (PWM_35_KOHM - R_ERROR) && res_ohm <= (PWM_35_KOHM + R_ERROR))
    {
        pwm_compare = PWM_35_US;
    }
    else if(res_ohm > PWM_30_KOHM && res_ohm < PWM_35_KOHM)
    {
        pwm_compare = (res_ohm - PWM_30_KOHM) / (PWM_35_KOHM - PWM_30_KOHM) * (PWM_35_US - PWM_30_US) + PWM_30_US;
    }
    else if(res_ohm >= (PWM_40_KOHM - R_ERROR) && res_ohm <= (PWM_40_KOHM + R_ERROR))
    {
        pwm_compare = PWM_40_US;
    }
    else if(res_ohm > PWM_35_KOHM && res_ohm < PWM_40_KOHM)
    {
        pwm_compare = (res_ohm - PWM_35_KOHM) / (PWM_40_KOHM - PWM_35_KOHM) * (PWM_40_US - PWM_35_US) + PWM_35_US;
    }
    else if(res_ohm >= (PWM_45_KOHM - R_ERROR) && res_ohm <= (PWM_45_KOHM + R_ERROR))
    {
        pwm_compare = PWM_45_US;
    }
    else if(res_ohm > PWM_40_KOHM && res_ohm < PWM_45_KOHM)
    {
        pwm_compare = (res_ohm - PWM_40_KOHM) / (PWM_45_KOHM - PWM_40_KOHM) * (PWM_45_US - PWM_40_US) + PWM_40_US;
    }
    else if(res_ohm >= (PWM_50_KOHM - R_ERROR) && res_ohm <= (PWM_50_KOHM + R_ERROR))
    {
        pwm_compare = PWM_50_US;
    }
    else if(res_ohm > PWM_45_KOHM && res_ohm < PWM_50_KOHM)
    {
        pwm_compare = (res_ohm - PWM_45_KOHM) / (PWM_50_KOHM - PWM_45_KOHM) * (PWM_50_US - PWM_45_US) + PWM_45_US;
    }
    else if(res_ohm >= (PWM_55_KOHM - R_ERROR) && res_ohm <= (PWM_55_KOHM + R_ERROR))
    {
        pwm_compare = PWM_55_US;
    }
    else if(res_ohm > PWM_50_KOHM && res_ohm < PWM_55_KOHM)
    {
        pwm_compare = (res_ohm - PWM_50_KOHM) / (PWM_55_KOHM - PWM_50_KOHM) * (PWM_55_US - PWM_50_US) + PWM_50_US;
    }
    else if(res_ohm >= (PWM_60_KOHM - R_ERROR) && res_ohm <= (PWM_60_KOHM + R_ERROR))
    {
        pwm_compare = PWM_60_US;
    }
    else if(res_ohm > PWM_55_KOHM && res_ohm < PWM_60_KOHM)
    {
        pwm_compare = (res_ohm - PWM_55_KOHM) / (PWM_60_KOHM - PWM_55_KOHM) * (PWM_60_US - PWM_55_US) + PWM_55_US;
    }
    else if(res_ohm >= (PWM_65_KOHM - R_ERROR) && res_ohm <= (PWM_65_KOHM + R_ERROR))
    {
        pwm_compare = PWM_65_US;
    }
    else if(res_ohm > PWM_60_KOHM && res_ohm < PWM_65_KOHM)
    {
        pwm_compare = (res_ohm - PWM_60_KOHM) / (PWM_65_KOHM - PWM_60_KOHM) * (PWM_65_US - PWM_60_US) + PWM_60_US;
    }
    else if(res_ohm >= (PWM_70_KOHM - R_ERROR) && res_ohm <= (PWM_70_KOHM + R_ERROR))
    {
        pwm_compare = PWM_70_US;
    }
    else if(res_ohm > PWM_65_KOHM && res_ohm < PWM_70_KOHM)
    {
        pwm_compare = (res_ohm - PWM_65_KOHM) / (PWM_70_KOHM - PWM_65_KOHM) * (PWM_70_US - PWM_65_US) + PWM_65_US;
    }
    else if(res_ohm >= (PWM_75_KOHM - R_ERROR) && res_ohm <= (PWM_75_KOHM + R_ERROR))
    {
        pwm_compare = PWM_75_US;
    }
    else if(res_ohm > PWM_70_KOHM && res_ohm < PWM_75_KOHM)
    {
        pwm_compare = (res_ohm - PWM_70_KOHM) / (PWM_75_KOHM - PWM_70_KOHM) * (PWM_75_US - PWM_70_US) + PWM_70_US;
    }
    else if(res_ohm >= (PWM_80_KOHM - R_ERROR) && res_ohm <= (PWM_80_KOHM + R_ERROR))
    {
        pwm_compare = PWM_80_US;
    }
    else if(res_ohm > PWM_75_KOHM && res_ohm < PWM_80_KOHM)
    {
        pwm_compare = (res_ohm - PWM_75_KOHM) / (PWM_80_KOHM - PWM_75_KOHM) * (PWM_80_US - PWM_75_US) + PWM_75_US;
    }
    else if(res_ohm >= (PWM_85_KOHM - R_ERROR) && res_ohm <= (PWM_85_KOHM + R_ERROR))
    {
        pwm_compare = PWM_85_US;
    }
    else if(res_ohm > PWM_80_KOHM && res_ohm < PWM_85_KOHM)
    {
        pwm_compare = (res_ohm - PWM_80_KOHM) / (PWM_85_KOHM - PWM_80_KOHM) * (PWM_85_US - PWM_80_US) + PWM_80_US;
    }
    else if(res_ohm >= (PWM_90_KOHM - R_ERROR) && res_ohm <= (PWM_90_KOHM + R_ERROR))
    {
        pwm_compare = PWM_90_US;
    }
    else if(res_ohm > PWM_85_KOHM && res_ohm < PWM_90_KOHM)
    {
        pwm_compare = (res_ohm - PWM_85_KOHM) / (PWM_90_KOHM - PWM_85_KOHM) * (PWM_90_US - PWM_85_US) + PWM_85_US;
    }
    else if(res_ohm >= (PWM_95_KOHM - R_ERROR) && res_ohm <= (PWM_95_KOHM + R_ERROR))
    {
        pwm_compare = PWM_95_US;
    }
    else if(res_ohm > PWM_90_KOHM && res_ohm < PWM_95_KOHM)
    {
        pwm_compare = (res_ohm - PWM_90_KOHM) / (PWM_95_KOHM - PWM_90_KOHM) * (PWM_95_US - PWM_90_US) + PWM_90_US;
    }
    else if(res_ohm >= (PWM_100_KOHM - R_ERROR) && res_ohm <= (PWM_100_KOHM + R_ERROR))
    {
        pwm_compare = PWM_100_US;
    }
    else if(res_ohm > PWM_95_KOHM && res_ohm < PWM_100_KOHM)
    {
        pwm_compare = (res_ohm - PWM_95_KOHM) / (PWM_100_KOHM - PWM_95_KOHM) * (PWM_100_US - PWM_95_US) + PWM_95_US;
    }
    else if(res_ohm > PWM_100_KOHM)
    {
        pwm_compare = PWM_100_US;
    }
    else
    {
        pwm_compare = PWM_10_US;
    }
}

/* 输出比较寄存器 */
void ccu4_0_SR0_INTERRUPT_HANDLER(void)
{
    XMC_CCU4_SLICE_StopTimer(pwm_HW);
    XMC_CCU4_SLICE_SetTimerCompareMatch(pwm_HW, pwm_compare / PWM_TICK_US);
    XMC_CCU4_SLICE_StartTimer(pwm_HW);
}


int main(void)
{
    cy_rslt_t result;

    /* Initialize the device and board peripherals */
    result = cybsp_init();
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Retarget Print */
    cy_retarget_io_init(dbg_uart_HW);

    XMC_VADC_GLOBAL_BackgroundAddChannelToSequence(VADC, 0, 5);
    XMC_VADC_GLOBAL_BackgroundTriggerConversion(VADC);

    /* Start system timer clock for 1ms heartbeat*/
    SysTick_Config(SystemCoreClock / TICKS_PER_SECOND);

    NVIC_SetPriority(ccu4_0_SR0_IRQN, 10);
    NVIC_EnableIRQ(ccu4_0_SR0_IRQN);

    uint16_t res_digit;
    float res_voltage;
    uint16_t cycle_times = 0;
    while(1)
    {
        cycle_times++;

        res_digit = XMC_VADC_GROUP_GetResult(VADC_G0, 5);
        res_voltage = 5.0f * res_digit / 4096; /* 当res_digit等于4096时，res_voltage等于5V，此时可调电阻R=0Ω */
        res_ohm = 5.0f * R1 / res_voltage - R1; /* 当res_digit等于2048时，res_voltage等于2.5V，此时可调电阻R=10kΩ */
        update_pwm_compare(); /* 更新PWM比较寄存器 */

        if(cycle_times == 1000)
        {
            cycle_times = 0;
            printf("Res(kohm):%.2f\r\n", res_ohm);
        }
        led_ctrl(toogle);
    }
    return 0;
}

/* [] END OF FILE */
